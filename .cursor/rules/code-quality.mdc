---
alwaysApply: true
---

# Code Quality and Best Practices

## Development Standards

### 1. TypeScript Requirements
- Use strict TypeScript typing throughout the codebase
- Define interfaces for all component props and function parameters
- Use proper type annotations for better code maintainability
- Avoid `any` type - use specific types or `unknown`

### 2. Code Organization
- Extract complex logic into utility functions in `utils/` folder
- Move duplicated constants to `constants/` files
- Group related functionality by domain (medicines, healthTrackers, etc.)
- Keep components focused on presentation logic

### 3. Component Reusability
- **ALWAYS** check `components/common/` before creating new components
- Reuse existing components whenever possible
- Create new common components only when necessary
- Extract complex markup into reusable components

## Code Quality Rules

### 1. Comments and Documentation
```typescript
// Add comments for complex logic or tricky techniques
const calculateNextDoseDate = (schedule: Schedule, lastTakenDate: Date) => {
  // Complex calculation logic that needs explanation
  // This function handles edge cases for different schedule types
  // ...
};

// Document complex business logic
/**
 * Prepares medicine data for API submission
 * Handles data transformation and validation
 */
const prepareMedicineData = (formData: MedicineFormData) => {
  // Implementation
};
```

### 2. Function Organization
- Keep functions small and focused on single responsibility
- Use pure functions when possible (no side effects)
- Extract complex logic into separate utility functions
- Use descriptive function and variable names

### 3. State Management
- Use TanStack Query for server state
- Use React hooks for local component state
- Keep state as close to where it's used as possible
- Avoid prop drilling - use context when necessary

## Code Formatting

### 1. Prettier Integration
- **ALWAYS** run prettier formatter for every changed file
- Use the project's prettier configuration
- Ensure consistent code formatting across the codebase

### 2. Import Organization
```typescript
// React and React Native imports first
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

// Third-party libraries
import { useQuery } from '@tanstack/react-query';

// Internal imports - services first
import { APIService } from '@/services/APIService';
import { LanguageService } from '@/services/language/LanguageService';

// Then components
import { PrimaryButton } from '@/components/common/buttons/PrimaryButton';

// Then utilities and types
import { formatDate } from '@/utils/date/formatDate';
import { MedicineData } from '@/types/medicines';
```

## Performance Best Practices

### 1. Component Optimization
```typescript
// Use React.memo for expensive components
export const ExpensiveComponent = React.memo<ComponentProps>(({ data }) => {
  // Component implementation
});

// Use useMemo for expensive calculations
const expensiveValue = useMemo(() => {
  return calculateExpensiveValue(data);
}, [data]);

// Use useCallback for event handlers
const handlePress = useCallback(() => {
  // Handler logic
}, [dependencies]);
```

### 2. List Performance
```typescript
// Use FlatList for large lists
<FlatList
  data={medicines}
  keyExtractor={(item) => item.id.toString()}
  renderItem={({ item }) => <MedicineCard medicine={item} />}
  getItemLayout={(data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index,
  })}
/>
```

## Security Best Practices

### 1. Data Handling
- Validate all user inputs

## Examples

### Good Code Structure
```typescript
// utils/entities/medicine/calculateNextDose.ts
export const calculateNextDoseDate = (
  schedule: Schedule,
  lastTakenDate: Date
): Date => {
  // Complex calculation logic
  // Well-documented and tested
};

// components/entities/medicine/MedicineCard.tsx
import React from 'react';
import { View, Text } from 'react-native';
import { LanguageService } from '@/services/language/LanguageService';
import { calculateNextDoseDate } from '@/utils/entities/medicine/calculateNextDose';
import { styles } from './styles';
import { MedicineCardProps } from './types';

export const MedicineCard: React.FC<MedicineCardProps> = ({ medicine }) => {
  const nextDoseDate = calculateNextDoseDate(medicine.schedule, medicine.lastTaken);
  
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{medicine.title}</Text>
      <Text style={styles.nextDose}>
        {LanguageService.translate("Next Dose")}: {formatDate(nextDoseDate)}
      </Text>
    </View>
  );
};
```

### Anti-Patterns to Avoid

❌ **Don't create components without checking existing ones**
❌ **Don't hardcode values that should be constants**
❌ **Don't skip TypeScript types**
❌ **Don't use `any` type**
❌ **Don't forget to run prettier**
❌ **Don't create large, monolithic components**
❌ **Don't duplicate logic across files**
❌ **Don't ignore error handling**

## Best Practices Summary

✅ **Always check existing components before creating new ones**
✅ **Use TypeScript strictly throughout the codebase**
✅ **Extract complex logic into utility functions**
✅ **Run prettier on every changed file**
✅ **Add comments for complex logic**
✅ **Follow established patterns and conventions**
✅ **Test your code thoroughly**
✅ **Keep components small and focused**
✅ **Use proper error handling**
✅ **Optimize for performance when needed**
